# -*- coding: utf-8 -*-
"""Копия блокнота "Практика 0.8.0.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YC72kAl55WyJ7fxOxYdbMrrxEFwk22kJ

# Задание 1

Задача: Создать чат бота для получения информации об исследованиях космоса

Описание: Создайте комплексное приложение командной строки, которое будет использоваться в качестве панели управления исследованиями космоса. Данное приложение будет обращаться к https://api.nasa.gov/ для предоставления пользователям набора информации о космосе, включая:

- Астрономическая картинка дня (APOD): Отображение APOD с пояснениями к нему.
- Фотографии с марсохода: позволяет пользователям выбирать и фильтровать фотографии с марсохода по дате и типу камеры.
- Объекты, сближающиеся с Землей (ОСЗ): Поиск и отображение информации об объекте, сближающихся с Землей, на определенную дату, включая их размеры и потенциальную опасность.
- Данные о космической погоде: Отображают последние данные о космической погоде, включая солнечные вспышки и геомагнитные бури.
Приложение должно позволять пользователям ориентироваться в этих функциях, корректно обрабатывать ошибки и обеспечивать удобство работы.

Требования:
- Пользовательский ввод: Приложение должно предложить пользователю ввести данные, чтобы выбрать, какую функцию он хочет изучить.
- Проверка данных: Убедитесь, что пользовательские данные (например, даты) проверены.
- Обработка ошибок: Корректно обрабатывайте ошибки API и неверные ответы.
- Представление данных: Представляйте данные в четкой и организованной форме.
- Опция выхода: позволяет пользователям выходить из приложения в любое время.
"""

import requests
from datetime import datetime


API_KEY = "W3mjqv34VdurWsd5BfXj21MdhEZziajty6SXfO0K"
BASE_URL = "https://api.nasa.gov"

def get_apod():
    response = requests.get(f"{BASE_URL}/planetary/apod?api_key={API_KEY}")
    response.raise_for_status()
    data = response.json()
    print("\nАстрономическая картинка дня:")
    print(f"Дата: {data['date']}")
    print(f"Заголовок: {data['title']}")
    print(f"Описание: {data['explanation']}")
    print(f"URL: {data['url']}")


def get_mars_photos(date, camera):
    rover = "curiosity"
    response = requests.get(f"{BASE_URL}/mars-photos/api/v1/rovers/{rover}/photos", params={
        "earth_date": date,
        "camera": camera,
        "api_key": API_KEY
    })
    response.raise_for_status()
    photos = response.json().get("photos", [])
    if not photos:
        print("Фотографии не найдены.")
        return
    print("\nФотографии с марсохода:")
    for photo in photos[:5]:
        print(f"ID: {photo['id']}, Камера: {photo['camera']['full_name']}, URL: {photo['img_src']}")


def get_neo_data(date):
    response = requests.get(f"{BASE_URL}/neo/rest/v1/feed", params={
        "start_date": date,
        "end_date": date,
        "api_key": API_KEY
    })
    response.raise_for_status()
    data = response.json().get("near_earth_objects", {}).get(date, [])
    if not data:
        print("Нет данных по объектам, сближающимся с Землей.")
        return
    print("\nОбъекты, сближающиеся с Землей:")
    for obj in data:
        print(f"Название: {obj['name']}, Диаметр (км): {obj['estimated_diameter']['kilometers']['estimated_diameter_max']}")
        print(f"Опасен: {'Да' if obj['is_potentially_hazardous_asteroid'] else 'Нет'}")


def get_space_weather():
    response = requests.get(f"{BASE_URL}/DONKI/FLR", params={"api_key": API_KEY})
    response.raise_for_status()
    flares = response.json()
    if not flares:
        print("Данные о солнечных вспышках отсутствуют.")
        return
    print("\nПоследние данные о солнечных вспышках:")
    for flare in flares[:5]:
        print(f"Дата начала: {flare['beginTime']}, Класс вспышки: {flare['classType']}")


def main():
    while True:
        print("\nВыберите раздел для получения информации:")
        print("1. Астрономическая картинка дня (APOD)")
        print("2. Фотографии с марсохода")
        print("3. Объекты, сближающиеся с Землей")
        print("4. Данные о космической погоде")
        print("5. Выход")

        choice = int(input("Введите номер раздела: "))
        if choice == 1:
            get_apod()
        elif choice == 2:
            date = input("Введите дату для получения фотографий: ")
            camera = input("Введите тип камеры (FHAZ, RHAZ, MAST и др.): ")
            get_mars_photos(date, camera)
        elif choice == 3:
            date = input("Введите дату для объектов, сближающихся с Землей: ")
            get_neo_data(date)
        elif choice == 4:
            get_space_weather()
        elif choice == 5:
            print("Выход из программы.")
            break


if __name__ == "__main__":
    main()

"""# Задание 2

Описание задачи

Цель этой задачи - создать скрипт на Python, который взаимодействует с API Чикагского института искусств (https://api.artic.edu/docs/) для извлечения и отображения произведений искусства. Скрипт должен позволять пользователям просматривать работы по страницам, фильтровать их по имени художника и просматривать подробную информацию о выбранных произведениях искусства. Ниже приведены требования и функциональные возможности, которые необходимо реализовать:

Требования:
Извлекать произведения искусства:

- Создайте функцию, которая извлекает список произведений искусства из API Чикагского института искусств.
Функция должна принимать параметр page для разбивки на страницы и возвращать список произведений искусства вместе с информацией о разбивке на страницы.
Фильтровать произведения искусства:

- Реализуйте функцию, которая фильтрует список произведений искусства на основе имени указанного художника. Функция должна возвращать список работ, которые соответствуют имени художника (без учета регистра).
Отображать подробную информацию об оформлении:

- Напишите функцию, которая отображает названия работ для пользователя и позволяет ему выбрать одну из них, введя соответствующий номер.
После выбора функция должна отображать подробную информацию о выбранном произведении, включая название, исполнителя, дату и носитель.
Разбивка на страницы и взаимодействие с пользователем:

- Создайте основную функцию, которая управляет выборкой произведений и взаимодействием с пользователем.

Разрешите пользователям перемещаться по страницам с произведениями искусства, выполнять фильтрацию по исполнителю или выходить из программы.

Если страниц с произведениями искусства несколько, укажите варианты перехода к следующей странице, предыдущей странице, фильтрации по исполнителю или выхода из программы.
"""

import requests


API_BASE_URL = "https://api.artic.edu/api/v1/artworks"
API_FIELDS = "id,title,artist_display,date_display,medium_display"


def fetch_artworks(page=1):
    params = {
        "page": page,
        "limit": 10,
        "fields": API_FIELDS
    }
    response = requests.get(API_BASE_URL, params=params)
    if response.status_code == 200:
        data = response.json()
        return data['data'], data['pagination']
    else:
        print("Ошибка при запросе к API.")
        return [], {}


def filter_artworks_by_artist(artworks, artist_name):
    return [artwork for artwork in artworks if artist_name.lower() in artwork['artist_display'].lower()]


def display_artwork_details(artwork):
    print("\nДетали выбранного произведения:")
    print(f"Название: {artwork['title']}")
    print(f"Исполнитель: {artwork['artist_display']}")
    print(f"Дата: {artwork['date_display']}")
    print(f"Носитель: {artwork['medium_display']}\n")


def main():
    page = 1

    while True:
        artworks, pagination = fetch_artworks(page)
        if not artworks:
            print("Нет доступных произведений для отображения.")
            break

        print(f"\nСтраница {page}")
        for idx, artwork in enumerate(artworks, start=1):
            print(f"{idx}. {artwork['title']} - {artwork['artist_display']}")

        print("\nВыберите действие:")
        print("1. Следующая страница")
        print("2. Предыдущая страница")
        print("3. Фильтрация по исполнителю")
        print("4. Просмотр подробностей произведения")
        print("5. Выход")

        choice = input("Введите номер действия: ")

        if choice == "1":
            if pagination.get('next_url'):
                page += 1
            else:
                print("Это последняя страница.")
        elif choice == "2":
            if pagination.get('prev_url'):
                page -= 1
            else:
                print("Это первая страница.")
        elif choice == "3":
            artist_name = input("Введите имя исполнителя для фильтрации: ")
            filtered_artworks = filter_artworks_by_artist(artworks, artist_name)
            if filtered_artworks:
                print("\nОтфильтрованные произведения:")
                for idx, artwork in enumerate(filtered_artworks, start=1):
                    print(f"{idx}. {artwork['title']} - {artwork['artist_display']}")
            else:
                print("Нет произведений, соответствующих данному исполнителю.")
        elif choice == "4":
            art_num = int(input("Введите номер произведения для просмотра деталей: ")) - 1
            if 0 <= art_num < len(artworks):
                display_artwork_details(artworks[art_num])
            else:
                print("Неверный номер произведения.")
        elif choice == "5":
            print("Выход из программы.")
            break
        else:
            print("Неверный выбор, попробуйте снова.")

if __name__ == "__main__":
    main()

"""# Задание 3

Задача: Создать программу по управлению портфелем криптовалют

Цель: Создать скрипт на Python, который извлекает цены на криптовалюты в режиме реального времени, позволяет пользователям управлять портфелем криптовалют, вычисляет общую стоимость портфеля, отслеживает изменения цен и предоставляет исторические данные о ценах для анализа.

Требования:
Получение текущих цен на криптовалюты:

Используйте https://docs.coingecko.com/ для получения актуальных цен на список криптовалют.

Управление портфелем:

- Позволяет пользователю создавать портфель криптовалют и управлять им, указывая количество каждой криптовалюты, которой он владеет.
- Расчитывает общую стоимость портфеля в указанной фиатной валюте (например, долларах США).

Отслеживание изменения цен:

- Отображение процентного изменения цены для каждой криптовалюты в портфеле за последние 24 часа.
- Выделите все криптовалюты, стоимость которых значительно увеличилась или снизилась.

Поиск исторических данных о ценах:

- Получение исторических данных о ценах на указанную криптовалюту за последнюю неделю.
- Предоставьте пользователю возможность визуализировать эти данные в простом текстовом формате (например, цены за день).

Взаимодействие с пользователем:

- Реализуйте интерфейс командной строки для ввода данных пользователем.
- Предоставьте опции для получения текущих цен, управления портфелем, просмотра изменений цен или анализа исторических данных.
"""

import requests
import pandas as pd
from datetime import datetime, timedelta


def get_crypto_price(crypto_ids, vs_currency="usd"):
    url = "https://api.coingecko.com/api/v3/simple/price"
    params = {
        "ids": ",".join(crypto_ids),
        "vs_currencies": vs_currency,
        "include_24hr_change": "true"
    }
    response = requests.get(url, params=params)
    if response.status_code == 200:
        return response.json()
    else:
        print("Ошибка при получении данных.")
        return None

class CryptoPortfolio:
    def __init__(self):
        self.portfolio = {}

    def add_crypto(self, crypto_id, amount):
        if crypto_id in self.portfolio:
            self.portfolio[crypto_id] += amount
        else:
            self.portfolio[crypto_id] = amount

    def remove_crypto(self, crypto_id, amount):
        if crypto_id in self.portfolio and self.portfolio[crypto_id] >= amount:
            self.portfolio[crypto_id] -= amount
            if self.portfolio[crypto_id] == 0:
                del self.portfolio[crypto_id]
        else:
            print(f"Недостаточно средств для удаления {amount} {crypto_id}.")

    def get_total_value(self, prices):
        total_value = 0
        for crypto_id, amount in self.portfolio.items():
            if crypto_id in prices:
                total_value += prices[crypto_id]['usd'] * amount
        return total_value


def get_historical_data(crypto_id, days=7, vs_currency="usd"):
    url = f"https://api.coingecko.com/api/v3/coins/{crypto_id}/market_chart"
    params = {
        "vs_currency": vs_currency,
        "days": days
    }
    response = requests.get(url, params=params)
    if response.status_code == 200:
        data = response.json()
        prices = data['prices']
        return [(datetime.utcfromtimestamp(price[0] // 1000).strftime('%Y-%m-%d'),
                 price[1]) for price in prices]
    else:
        print("Ошибка при получении данных.")
        return None


def main():
    portfolio = CryptoPortfolio()
    crypto_ids = ["bitcoin", "ethereum", "litecoin"]

    while True:
        print("\n1. Получить текущие цены")
        print("2. Управление портфелем")
        print("3. Просмотр общей стоимости портфеля")
        print("4. Отслеживание изменений цен")
        print("5. Анализ исторических данных")
        print("6. Выход")
        choice = input("Выберите действие: ")

        if choice == "1":
            prices = get_crypto_price(crypto_ids)
            if prices:
                for crypto, data in prices.items():
                    print(f"{crypto.capitalize()}: ${data['usd']:.2f} (Изменение за 24ч: {data['usd_24h_change']:.2f}%)")

        elif choice == "2":
            action = input("add/remove:").strip().lower()
            crypto_id = input("Введите ID криптовалюты:").strip().lower()
            amount = float(input("Введите количество: "))

            if action == "add":
                portfolio.add_crypto(crypto_id, amount)
                print(f"Добавлено {amount} {crypto_id}.")
            elif action == "remove":
                portfolio.remove_crypto(crypto_id, amount)
                print(f"Удалено {amount} {crypto_id}.")

        elif choice == "3":
            prices = get_crypto_price(list(portfolio.portfolio.keys()))
            if prices:
                total_value = portfolio.get_total_value(prices)
                print(f"Общая стоимость портфеля: ${total_value:.2f}")

        elif choice == "4":
            prices = get_crypto_price(list(portfolio.portfolio.keys()))
            if prices:
                for crypto, data in prices.items():
                    change = data.get("usd_24h_change", 0)
                    print(f"{crypto.capitalize()}: {change:.2f}% изменение за 24 часа")
                    if abs(change) > 10:
                        print(f"Значительное изменение в {crypto.capitalize()}: {change:.2f}%")

        elif choice == "5":
            crypto_id = input("Введите ID криптовалюты для анализа").strip().lower()
            days = int(input("Введите количество дней для анализа").strip())
            historical_data = get_historical_data(crypto_id, days=days)
            if historical_data:
                print(f"Исторические данные за {days} дней для {crypto_id.capitalize()}:")
                for date, price in historical_data:
                    print(f"{date}: ${price:.2f}")

        elif choice == "6":
            print("Выход.")
            break


if __name__ == "__main__":
    main()

"""# Дополнительно: Задание 4

Задание 4: Проектное

Вам необходимо самостоятельно найти откртое API предоставляющее информацию в открытом доступе и реализовать собственный проект!


Критерии приемки результата:

- Проект включает в себя не менее 5 возможостей для пользователя
- Проект позволяет использовать все возможности проекта пользователю при помощи взаимодействия через коммандную строку
- Проект работает с открытым API (это значит что при проверке вашей работы преподавателем, преподавателю необходимо просто запустить ячейку с кодом вашего проекта и она будет работать без дополнительных манипуляции)
- Проект должен обязательно включать в себя ряд используемых конструкции:
    - Функции
    - Условные конструкции
    - Ввод/вывод
    - Словари/Списки
- Допускается использование библиотек:
    - requests
    - datetime
    - random

**Здесь добавьте описание вашего проекта**
"""

#  А здесь код