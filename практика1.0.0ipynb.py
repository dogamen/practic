# -*- coding: utf-8 -*-
"""Копия блокнота "Практика 1.0.0.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s3pRcAofr0wbR3utVKlblkvgseAtkJgi

ФИО:

# Задание (совместное с преподавателем)

Напишите систему для учёта отпусков с возможностью узнавать, сколько дней отпуска осталось у того или иного сотрудника.
Для этого создайте класс Employee со следующими методами:

- Метод consume_vacation должен отвечать за списание дней отпуска.

Единственный параметр этого метода (кроме self) — количество потраченных отпускных дней (целое число).

При вызове метода consume_vacation соответствующее количество дней должно вычитаться из общего числа доступных отпускных дней сотрудника.

Чтобы определить число доступных отпускных дней конкретного сотрудника, в классе опишите атрибут экземпляра |, который по умолчанию будет равен значению атрибута класса vacation_days, и используйте этот атрибут в работе метода.

- Метод get_vacation_details должен возвращать остаток отпускных дней сотрудника в формате: ```Остаток отпускных дней: <число>.```


Чтобы проверить работу программы:
1. Создайте экземпляр класса Employee.
2. Вызовите метод consume_vacation, указав подходящее значение аргумента, например 7.
3. Вызовите метод get_vacation_details.
"""

class Employee:
    vacation_days = 28

    def __init__(self, first_name, second_name, gender):
        self.first_name = first_name
        self.second_name = second_name
        self.gender = gender
        self.remaining_vacation_days = self.vacation_days

    def consume_vacation(self, days):
        self.remaining_vacation_days -= days

    def get_vacation_details(self):
        return f'остаток отпускных дней: {self.remaining_vacation_days}.'

employee = Employee('Олег', "СуперОлег", "м")
employee2 = Employee('Олег', "НеСуперОлег", "м")

print(f'\nИмя:',employee.first_name,
      f'\nФамилия:',employee.second_name,
      f'\nПол:',employee.gender,
      f'\nКоличество доступных дней:',employee.remaining_vacation_days,'\n')

print('-'*20)

print(f'\nИмя:',employee2.first_name,
      f'\nФамилия:',employee2.second_name,
      f'\nПол:',employee2.gender,
      f'\nКоличество доступных дней:',employee2.remaining_vacation_days,'\n')

"""# Задание 1

Задание:

Создайте класс с именем Rectangle который имеет:
- Атрибуты ширины и высоты.
- Метод расчета площади.
- Метод расчета периметра.
- Метод отображения размеров прямоугольника.

Создайте экземпляр класса Rectangleи продемонстрируйте его функциональность.
"""

class Rectangle:

    def __init__(self, length, width):
        self.length = length
        self.width = width
        self.square = length * width
        self.perimeter = 2*(length + width)

length = int(input())
width = int(input())

rectangle = Rectangle(length, width)

print(f'\nплощадь:', rectangle.square,
      f'\nпериметр:', rectangle.perimeter,
      f'\nдлина:', rectangle.length,
      f'\nширина:', rectangle.width)

"""# Задание 2

Задание: Создайте мини версию банковской системы:


Инструкции:

1. Создайте класс BankAccountсо следующими атрибутами:
    - account_holder -  владелец счета
    - balance - баланс счета

2. Реализуйте следующие методы:
    - Метод для инициализации владельца счета: имя владельца счета и установите начальный баланс на 0.
    - deposit(amount): Добавьте указанную сумму к балансу.
    - withdraw(amount): Вычесть указанную сумму из баланса, если средств достаточно; в противном случае вывести предупреждение.
    - get_balance(): Возврат текущего баланса.


Создайте объект класса и продемонстрируйте его возможности
"""

class BankAccount:
    def __init__(self, account_holder):
        self.account_holder = account_holder
        self.balance = 0

    def deposit(self, amount):
        self.balance += amount
        print(f'на счет добавлено:{amount} текущий баланс:{self.balance}')

    def withdraw(self, amount):
        if amount > self.balance:
            print('недостаточно средств на счете')
        else:
            self.balance -= amount
            print(f'снято со счета:{amount} текущий баланс:{self.balance}')

    def get_balance(self):
        return self.balance

account_holder = input('введите имя владельца счета:')
bank_account = BankAccount(account_holder)

print(f'создан счет для {bank_account.account_holder}')
print(f'баланс: {bank_account.get_balance()}')

while True:
    print('выберите вариант', '1депозит', '2вывод', '3баланс', sep='\n')
    a = int(input())
    if a == 1:
        bank_account.deposit(int(input()))
    elif a == 2:
        bank_account.withdraw(int(input()))
    elif a == 3:
        print(f"текущий баланс: {bank_account.get_balance()}")
    else:
        break

"""# Задание 3

Возьмите код и задание (Рыцарь и дракон) из предыдущей практики и реализуйте его с применением классов
"""

import random

class Character:
    def __init__(self, name, hp):
        self.name = name
        self.hp = hp
        self.effects = {'огонь': 0, 'заморозка': 0, 'яд': 0}

    def apply_effects(self):
        for effect, turns in self.effects.items():
            if turns > 0:
                if effect == 'огонь':
                    self.hp -= random.randint(5, 7)
                elif effect == 'яд':
                    self.hp -= random.randint(2, 5) * 2
                self.effects[effect] -= 1

    def is_alive(self):
        return self.hp > 0


class Dragon(Character):
    def attack(self):
        return random.randint(10, 20)

    def use_skill(self):
        skill_name = random.choice(['огненный шар', 'замораживающий дождь', 'малое исцеление', 'ядовитое облако'])
        if skill_name == 'огненный шар':
            return random.randint(5, 7), 'огонь', 2
        elif skill_name == 'замораживающий дождь':
            return 0, 'заморозка', 1
        elif skill_name == 'малое исцеление':
            return random.randint(10, 15), 'исцеление', 1
        else:
            return random.randint(2, 5) * 2, 'яд', 3


class Player(Character):
    def __init__(self, name, hp):
        super().__init__(name, hp)
        self.power_hit_counter = 0
        self.poison_hit_counter = 0
        self.defense_counter = 0

    def attack(self):
        return random.randint(15, 25)

    def special_attack(self, turn_count):
        print('1. Сильный удар\n2. Отравляющий удар\n3. Лечение')
        choice = input('Выбор: ')
        if choice == '1' and turn_count % 2 == 0:
            return random.randint(30, 50)
        elif choice == '2' and turn_count % 5 == 0:
            return random.randint(10, 20)
        elif choice == '3':
            return -random.randint(20, 30)
        else:
            print('Неверный выбор или атака недоступна.')
            return 0


class Game:
    def __init__(self):
        self.player = Player("Игрок", 300)
        self.dragon = Dragon("Дракон", 500)
        self.turn_count = 0

    def play_turn(self):
        print('1. Атака\n2. Специальная атака\n3. Защита')
        action = input('Выбор: ')

        if action == '1':
            damage = self.player.attack()
            self.dragon.hp -= damage
            print(f'Вы нанесли {damage} урона Дракону!')
        elif action == '2':
            damage = self.player.special_attack(self.turn_count)
            if damage < 0:
                self.player.hp -= damage
                print(f'Вы исцелились на {-damage} HP!')
            else:
                self.dragon.hp -= damage
                print(f'Вы нанесли {damage} урона специальной атакой!')
        else:
            print('Неверный выбор.')

        self.dragon.apply_effects()
        self.player.apply_effects()

        if self.dragon.is_alive():
            if self.turn_count % 3 == 0:
                damage, effect, turns = self.dragon.use_skill()
                if effect == 'исцеление':
                    self.dragon.hp += damage
                    print(f'Дракон исцелился на {damage} HP!')
                else:
                    self.player.effects[effect] = turns
                    print(f'Дракон применяет {effect} на {turns} ход(ов).')
            else:
                damage = self.dragon.attack()
                self.player.hp -= damage
                print(f'Дракон атакует и наносит {damage} урона!')

        self.turn_count += 1

    def check_winner(self):
        if not self.player.is_alive():
            print('Игрок побежден!')
            return True
        elif not self.dragon.is_alive():
            print('Дракон побежден!')
            return True
        return False

    def start(self):
        print('Начинается битва между Игроком и Драконом!')
        while True:
            self.play_turn()
            if self.check_winner():
                break
            print(f'HP Игрока: {self.player.hp}, HP Дракона: {self.dragon.hp}')
            print('===')


if __name__ == "__main__":
    game = Game()
    game.start()

#честно сказать думал его невозможно победить)

"""# Дополнительное задание

Задача: Система управления библиотекой

**Цель**
Создайте простую систему управления библиотекой, которая позволит пользователям добавлять книги, брать книги, возвращать книги и просматривать список доступных книг.

**Требования**

1. **Определение класса**:
   – Создайте класс с именем «Book» со следующими атрибутами:
     - `title`
     - `автор`
     - `isbn`
     - `is_borrowed` (по умолчанию `False`)

2. **Класс библиотеки**:
   - Создайте класс с именем Library, который управляет коллекцией книг.
   - Класс должен иметь следующие методы:
     - `__init__(self)`: инициализирует пустой список книг.
     - `add_book(self, book: Book)`: добавляет новую книгу в библиотеку.
     - `borrow_book(self, isbn: str)`: помечает книгу как заимствованную. Если книга не найдена или уже взята, выведите соответствующее сообщение.
     - `return_book(self, isbn: str)`: помечает книгу как возвращенную. Если книга не найдена или не была взята взаймы, выведите соответствующее сообщение.
     - `list_available_books(self)`: печатает список всех доступных книг в библиотеке.
     - `find_book(self, isbn: str)`: возвращает объект книги, если он найден, в противном случае возвращает `None`.

3. **Взаимодействие с пользователем**:
   - Создайте простое текстовое меню, которое позволит пользователям:
     - Добавить книгу
     - Одолжить книгу
     - Вернуть книгу
     - Список доступных книг
     - Выйти из программы
"""

